// ============================================================
// OSE Combat & Morale — attack resolution, morale, reactions
//
// Descending AC system (lower = better). Uses ordered enums,
// entity groups, conditions, events, hooks, and resources for
// rich type-safe combat modeling.
//
// Reference: OSE Reference Booklet (pp. 19-20, 116-124)
// ============================================================

system "OSE Combat" {

    // ───────────────────────── Enums ─────────────────────────

    enum AttackOutcome { Miss, Hit }
    enum MoraleOutcome { Hold, Fail }

    // Ordered: enables comparison (Hostile < Friendly)
    enum ReactionOutcome ordered {
        Hostile,
        Unfriendly,
        Neutral,
        Indifferent,
        Friendly
    }

    // Ordered: enables phase comparison and sequencing
    enum CombatPhase ordered {
        Declaration,
        Initiative,
        Morale,
        Movement,
        Missile,
        Magic,
        Melee,
        EndOfRound
    }

    enum InitiativeWinner { Party, Monsters, Simultaneous }
    enum PhaseActorSlot { Both, Party, Monsters, Simultaneous, System }

    // Replaces is_missile/is_melee int flags
    enum WeaponMode { Melee, Missile }

    // 4-way surprise matrix
    enum SurpriseState {
        NoSurprise,
        PartySurprises,
        MonstersSurprise,
        Both
    }

    // Custom Duration for OSE effects
    enum Duration {
        end_of_round,
        rounds(count: int),
        indefinite
    }


    // ───────────────────── Structs ─────────────────────

    struct AttackResolution {
        outcome: AttackOutcome
        attack_mod: int
        damage: int
    }

    struct EncounterStart {
        party_roll: int
        monster_roll: int
        surprise: SurpriseState
        distance: int
    }

    // Phase-specific resource tokens for the action economy
    struct TurnBudget {
        movement: int = 0
        attack: int = 0
        spell: int = 0
        morale: int = 0
    }


    // ──────────────────── Tags ───────────────────────

    // Semantic tag for entity-level attack resolution mechanics.
    // Enables selector-targeted modify clauses (e.g. Fleeing).
    tag attack_resolution


    // ─────────────────── Groups ──────────────────────

    group CombatantCore {
        name: string
        max_hp: int
        hp: resource(0..=max_hp)
        ac: int
        thac0: int = 19
    }

    group MeleeCapable {
        str_mod: int = 0
        melee_damage_dice: int = 1
        melee_damage_sides: int = 6
        melee_weapon_mod: int = 0
    }

    group MissileCapable {
        dex_mod: int = 0
        short_range: int
        medium_range: int
        long_range: int
        missile_damage_dice: int = 1
        missile_damage_sides: int = 6
        missile_weapon_mod: int = 0
    }

    group MonsterStats {
        hd: int
        morale_score: int
    }

    group Spellcasting {
        has_spells_prepared: bool = false
    }


    // ──────────────────── Entity ──────────────────────

    entity Combatant {
        include CombatantCore
        optional MeleeCapable
        optional MissileCapable
        optional MonsterStats
        optional Spellcasting
    }


    // ──────────────────── Tables ──────────────────────

    // Monster HD -> THAC0. HD 0 = normal humans. Wildcard covers HD 19+.
    table monster_thac0(hd: int) -> int {
        0       => 20,
        1..=3   => 19,
        4..=6   => 17,
        7..=9   => 14,
        10..=12 => 12,
        13..=15 => 10,
        16..=18 => 8,
        _       => 6
    }

    // Reaction roll outcome table (2d6 + CHA modifier).
    table reaction_outcome(roll: int) -> ReactionOutcome {
        2       => Hostile,
        3..=5   => Unfriendly,
        6..=8   => Neutral,
        9..=11  => Indifferent,
        12      => Friendly
    }


    // ─────────────── Derives (pure computation) ───────────────

    // Target number: THAC0 minus defender's AC.
    // Example: THAC0 19 vs AC 5 (chain mail) -> need 14 on d20.
    derive target_number(thac0: int, ac: int) -> int {
        thac0 - ac
    }

    // AC from equipment and DEX. Lower = better in descending AC.
    derive calc_ac(armour_ac: int, shield_bonus: int, dex_mod: int) -> int {
        armour_ac - shield_bonus - dex_mod
    }

    // Missile range modifier: short +1, medium 0, long -1.
    derive missile_range_mod(
        distance: int,
        short_range: int,
        medium_range: int,
        long_range: int
    ) -> int {
        if short_range > medium_range || medium_range > long_range {
            error("invalid range brackets")
        } else {
            match {
                distance < 0             => error("distance must be >= 0"),
                distance <= short_range  => 1,
                distance <= medium_range => 0,
                distance <= long_range   => -1,
                _                        => error("distance exceeds weapon long range")
            }
        }
    }

    // Determine weapon mode from combatant capabilities and distance.
    // Versatile combatants (both melee and missile) use missile at range.
    // Disjunctive `with`: combatant must have at least one combat capability.
    // Neither group's fields are narrowed — `has` guards access each one.
    derive determine_weapon_mode(
        combatant: Combatant with MeleeCapable | MissileCapable,
        distance: int
    ) -> WeaponMode {
        if combatant has MissileCapable {
            if combatant has MeleeCapable {
                if distance > 10 { WeaponMode.Missile } else { WeaponMode.Melee }
            } else {
                WeaponMode.Missile
            }
        } else if combatant has MeleeCapable {
            WeaponMode.Melee
        } else {
            error("combatant has no combat capability")
        }
    }

    // Phase actor order determined by initiative winner.
    // Winner's slots precede loser's so callers iterate in order.
    derive phase_actor_order(
        phase: CombatPhase,
        initiative_winner: InitiativeWinner
    ) -> list<PhaseActorSlot> {
        match phase {
            CombatPhase.Declaration => [PhaseActorSlot.Both],
            CombatPhase.Initiative  => [PhaseActorSlot.Both],
            CombatPhase.Morale      => [PhaseActorSlot.Monsters],
            CombatPhase.EndOfRound  => [PhaseActorSlot.System],
            _ => match initiative_winner {
                InitiativeWinner.Party        => [PhaseActorSlot.Party, PhaseActorSlot.Monsters],
                InitiativeWinner.Monsters     => [PhaseActorSlot.Monsters, PhaseActorSlot.Party],
                InitiativeWinner.Simultaneous => [PhaseActorSlot.Simultaneous]
            }
        }
    }

    // Combat round phases in execution order.
    derive phase_sequence() -> list<CombatPhase> {
        [
            CombatPhase.Declaration,
            CombatPhase.Initiative,
            CombatPhase.Morale,
            CombatPhase.Movement,
            CombatPhase.Missile,
            CombatPhase.Magic,
            CombatPhase.Melee,
            CombatPhase.EndOfRound
        ]
    }

    // Per-phase action budget for a combatant.
    // Takes actor so conditions (e.g. Surprised) can modify per-entity.
    // Struct defaults on TurnBudget allow omitting zero-valued fields.
    derive action_budget(actor: Combatant, phase: CombatPhase) -> TurnBudget {
        match phase {
            CombatPhase.Morale   => TurnBudget { morale: 1 },
            CombatPhase.Movement => TurnBudget { movement: 1 },
            CombatPhase.Missile  => TurnBudget { attack: 1 },
            CombatPhase.Magic    => TurnBudget { spell: 1 },
            CombatPhase.Melee    => TurnBudget { attack: 1 },
            _                    => TurnBudget {}
        }
    }

    // Whether a phase should be skipped this round.
    derive skip_phase(
        phase: CombatPhase,
        has_spells_declared: bool,
        has_living_monsters: bool
    ) -> bool {
        match phase {
            CombatPhase.Magic  => !has_spells_declared,
            CombatPhase.Morale => !has_living_monsters,
            _                  => false
        }
    }

    // Whether a morale check should be triggered based on casualties.
    // OSE triggers when: first monster death, or half or more killed.
    derive should_check_morale(
        deaths: int,
        initial: int,
        first_death_checked: bool,
        half_killed_checked: bool
    ) -> bool {
        let first_death_trigger = deaths >= 1 && !first_death_checked
        let half_killed_trigger =
            initial > 0 &&
            deaths * 2 >= initial &&
            !half_killed_checked
        first_death_trigger || half_killed_trigger
    }

    // Evasion chance percentage (OSE evasion table).
    derive evasion_chance(party_size: int, fewer_monsters: bool) -> int {
        match {
            party_size <= 4  && fewer_monsters => 70,
            party_size <= 4                    => 50,
            party_size <= 12 && fewer_monsters => 50,
            party_size <= 12                   => 35,
            party_size <= 24 && fewer_monsters => 35,
            party_size <= 24                   => 25,
            fewer_monsters                     => 25,
            _                                  => 10
        }
    }

    // Initiative model: "group" = 1d6 per side (OSE default).
    derive initiative_model() -> string {
        "group"
    }


    // ────────────────── Events ──────────────────────

    event round_start(observer: Combatant) {}
    event round_end(observer: Combatant) {}

    // Fired by the host when casualties warrant a morale check.
    event morale_triggered(observer: Combatant) {
        deaths: int
        initial_count: int
    }


    // ────────────────── Conditions ──────────────────

    // Applied when morale check fails. Forces all attacks to miss.
    // Uses selector to target all #attack_resolution mechanics at once.
    condition Fleeing on bearer: Combatant {
        modify [#attack_resolution](attacker: bearer) {
            result.outcome = AttackOutcome.Miss
            result.damage = 0
        }
    }

    // Applied during surprise rounds. Zeroes out action budget.
    condition Surprised on bearer: Combatant {
        modify action_budget(actor: bearer) {
            result.movement = 0
            result.attack = 0
            result.spell = 0
            result.morale = 0
        }
    }


    // ──────────────── Actions ───────────────────

    action Move on actor: Combatant () {
        cost { movement }
        resolve {}
    }

    action MeleeAttack on actor: Combatant with MeleeCapable (target: Combatant) {
        cost { attack }
        resolve {
            let result = resolve_melee_attack(actor, target)
            match result.outcome {
                AttackOutcome.Hit => { target.hp -= result.damage },
                _ => {}
            }
        }
    }

    action MissileAttack on actor: Combatant with MissileCapable (
        target: Combatant,
        distance: int
    ) {
        cost { attack }
        resolve {
            let result = resolve_missile_attack(actor, target, distance)
            match result.outcome {
                AttackOutcome.Hit => { target.hp -= result.damage },
                _ => {}
            }
        }
    }

    action CastSpell on actor: Combatant with Spellcasting () {
        cost { spell }
        resolve {}
    }

    action Regroup on actor: Combatant () {
        cost { morale }
        resolve {}
    }


    // ──────────────── Hooks ────────────────────

    // Automatic morale check when triggered by casualties.
    // The host fires morale_triggered; this hook resolves it.
    hook MoraleAutoCheck on creature: Combatant with MonsterStats as ms (
        trigger: morale_triggered(observer: creature)
    ) {
        let result = morale_check(creature.ms.morale_score)
        match result {
            MoraleOutcome.Fail => {
                apply_condition(creature, Fleeing, Duration.indefinite)
            },
            _ => {}
        }
    }


    // ──────────────── Prompts ──────────────────

    prompt gm_ruling(context: string) -> string {
        hint: "The referee makes a ruling based on the situation"
    }


    // ─────────── Mechanics (dice, no mutation) ──────────────

    // d20 attack roll. Natural 1 always misses; natural 20 always hits.
    mechanic attack_roll(
        thac0: int,
        target_ac: int,
        attack_mod: int = 0
    ) -> AttackOutcome {
        let target = target_number(thac0, target_ac)
        let result = roll(1d20)
        match {
            result.unmodified == 1  => AttackOutcome.Miss,
            result.unmodified == 20 => AttackOutcome.Hit,
            result.total + attack_mod >= target => AttackOutcome.Hit,
            _ => AttackOutcome.Miss
        }
    }

    // Damage roll. Minimum damage is always 1.
    mechanic damage_roll(
        damage_dice: int,
        damage_sides: int,
        damage_mod: int = 0
    ) -> int {
        let result = roll(dice(damage_dice, damage_sides))
        max(1, result.total + damage_mod)
    }

    // Entity-level melee attack resolution. Conditions can modify this.
    mechanic resolve_melee_attack(
        attacker: Combatant with MeleeCapable as melee,
        target: Combatant,
        backstab_mult: int = 1
    ) -> AttackResolution #attack_resolution {
        if backstab_mult < 1 {
            error("backstab_mult must be >= 1")
        } else {
            let mod = attacker.melee.str_mod
            let damage_mod = attacker.melee.str_mod + attacker.melee.melee_weapon_mod
            let outcome = attack_roll(attacker.thac0, target.ac, mod)

            let damage = match outcome {
                AttackOutcome.Hit => match {
                    backstab_mult > 1 => {
                        let raw = roll(dice(attacker.melee.melee_damage_dice, attacker.melee.melee_damage_sides))
                        max(1, raw.total * backstab_mult + damage_mod)
                    },
                    _ => damage_roll(attacker.melee.melee_damage_dice, attacker.melee.melee_damage_sides, damage_mod)
                },
                _ => 0
            }

            AttackResolution { outcome: outcome, attack_mod: mod, damage: damage }
        }
    }

    // Entity-level missile attack resolution. Conditions can modify this.
    mechanic resolve_missile_attack(
        attacker: Combatant with MissileCapable as missile,
        target: Combatant,
        distance: int
    ) -> AttackResolution #attack_resolution {
        let range_mod = missile_range_mod(
            distance, attacker.missile.short_range, attacker.missile.medium_range, attacker.missile.long_range
        )
        let mod = attacker.missile.dex_mod + range_mod
        let outcome = attack_roll(attacker.thac0, target.ac, mod)

        let damage = match outcome {
            AttackOutcome.Hit => damage_roll(
                attacker.missile.missile_damage_dice,
                attacker.missile.missile_damage_sides,
                attacker.missile.missile_weapon_mod
            ),
            _ => 0
        }

        AttackResolution { outcome: outcome, attack_mod: mod, damage: damage }
    }

    // Morale check: 2d6 vs morale score. Above = fail.
    mechanic morale_check(morale: int) -> MoraleOutcome {
        let result = roll(2d6)
        if result.total > morale { MoraleOutcome.Fail } else { MoraleOutcome.Hold }
    }

    // Group initiative: 1d6 per side.
    mechanic group_initiative() -> int {
        let result = roll(1d6)
        result.total
    }

    // Individual initiative: 1d6 + DEX modifier.
    mechanic individual_initiative(dex_mod: int = 0) -> int {
        let result = roll(1d6)
        result.total + dex_mod
    }

    // Reaction roll: 2d6 + CHA modifier, clamped to table range.
    mechanic reaction_roll(cha_mod: int = 0) -> ReactionOutcome {
        let result = roll(2d6)
        let clamped = min(12, max(2, result.total + cha_mod))
        reaction_outcome(clamped)
    }

    // Surprise roll: 1d6. Result of 1-2 means surprised.
    mechanic surprise_roll() -> int {
        let result = roll(1d6)
        result.total
    }

    // Dungeon encounter distance: normal 2d6x10 ft, surprised 1d4x10 ft.
    mechanic dungeon_encounter_distance(surprised: bool = false) -> int {
        let d = if surprised { roll(1d4) } else { roll(2d6) }
        d.total * 10
    }

    // Wilderness encounter distance: normal 4d6x10 yd, surprised 1d4x10 yd.
    mechanic wilderness_encounter_distance(surprised: bool = false) -> int {
        let d = if surprised { roll(1d4) } else { roll(4d6) }
        d.total * 10
    }

    // Dungeon encounter opening sequence.
    mechanic dungeon_encounter_sequence() -> EncounterStart {
        let party_roll = surprise_roll()
        let monster_roll = surprise_roll()
        let party_surprised = party_roll <= 2
        let monster_surprised = monster_roll <= 2
        let surprise = match {
            party_surprised && monster_surprised => SurpriseState.Both,
            party_surprised                      => SurpriseState.MonstersSurprise,
            monster_surprised                    => SurpriseState.PartySurprises,
            _                                    => SurpriseState.NoSurprise
        }
        let distance = dungeon_encounter_distance(party_surprised || monster_surprised)
        EncounterStart {
            party_roll: party_roll,
            monster_roll: monster_roll,
            surprise: surprise,
            distance: distance
        }
    }

    // Wilderness encounter opening sequence.
    mechanic wilderness_encounter_sequence() -> EncounterStart {
        let party_roll = surprise_roll()
        let monster_roll = surprise_roll()
        let party_surprised = party_roll <= 2
        let monster_surprised = monster_roll <= 2
        let surprise = match {
            party_surprised && monster_surprised => SurpriseState.Both,
            party_surprised                      => SurpriseState.MonstersSurprise,
            monster_surprised                    => SurpriseState.PartySurprises,
            _                                    => SurpriseState.NoSurprise
        }
        let distance = wilderness_encounter_distance(party_surprised || monster_surprised)
        EncounterStart {
            party_roll: party_roll,
            monster_roll: monster_roll,
            surprise: surprise,
            distance: distance
        }
    }
}
